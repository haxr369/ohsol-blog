---
title: LeetCode Week 1
date: 2025-11-09
lastmod: 2025-11-09
tags: ['LeetCode', 'Algorithm', 'Week 1']
draft: true
summary: 'LeetCode Week 1 문제 풀이 및 코드리뷰 정리'
---

## 목차

<TOCInline toc={props.toc} exclude="목차" toHeading={(2, 3)} />

## 문제 풀이 중 새로운 기술 습득


### Java Comparator, Comparable API 비교 및 사용 방법

```java
    Map<Integer, Integer> mp = new HashMap<>();
    for (int n : nums) {
      if (mp.containsKey(n)) {
        mp.put(n, mp.get(n) + 1);
      } else {
        mp.put(n, 1);
      }
    }
    List<Integer> li = mp.entrySet().stream()
        // 값을 기준으로 내림차순 정렬
        .sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed())
        .limit(k)
        .map(Map.Entry::getKey)
        .collect(Collectors.toList());

```

위와 같이 HashMap을 Stream으로 변환하여 정렬하고 원하는 개수만큼 추출하는 방법이 있다.
나는 여기서 sorted에 들어가는 Comparator를 직접 구현하는 방법을 찾아보았다.

보통 sorted에 들어가는 Comparator 객체는 아래와 같이 구현한다.
```Java
Comparator<Integer> comparator = new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1.compareTo(o2);
    }
};
```
이 코드를 람사식으로 표현하면 아래와 같다. Java8 이후부터 사용 가능.
```Java
Comparator<Integer> comparator = (o1, o2) -> o1.compareTo(o2);
```

문제의 경우 파라미터가 `Map.Entry<Integer,Integer>` 타입이므로 아래와 같이 구현할 수 있다.
```Java
.sorted((o1, o2) -> o2.getValue().compareTo(o1.getValue()))

```

## 코드리뷰 내용 정리

### 재귀로 DP를 탑다운 방식으로 구현하는 방법

```Java
class Solution {
    /**
    인접한 두 집을 방문하면 안된다.
    i번째 집을 방문하면 i+1번째 집은 방문X
    dp[i] = max(dp[i-1], nums[i] + dp[i-2])
     */
    public int rob(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, -1);
        int ans = dfs(nums.length-1, dp, nums);
        return ans;
    }

    /**
    재귀를 이용한 DP
    탑다운 방식으로 최상위 DP 값을 참조하기 위해 하위 DP 값을 만들기
    dp의 초기값은 -1.
     */
    public int dfs(int idx, int[] dp, int[] nums){
        
        // 처리할 수 없는 초기값을 하드코딩
        if(idx<0){
            return 0;
        } else if(dp[idx] != -1){ // 이미 처리한 값이면 바로 리턴
            return dp[idx];
        }
        
        // 찾지 못한 값을 만들고 리턴하기
        dp[idx] = Integer.max(dfs(idx-1, dp, nums)
                    , nums[idx] + dfs(idx-2, dp, nums));
        return dp[idx];
    }
}
```

탑다운 재귀 DP의 핵심은 알거나 확정할 수 있는 값은 바로 리턴하고
모르거나 만들어야하는 값은 dfs 함수를 호출하여 만들어서 리턴하는 것이다.